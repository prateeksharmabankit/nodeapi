// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import { isTokenCredential, isNode } from "@azure/core-http";
import { Aborter } from "./Aborter";
import { BlobClient } from "./internal";
import { AppendBlob } from "./generated/lib/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { URLConstants } from "./utils/constants";
import { setURLParameter, extractConnectionStringParts } from "./utils/utils.common";
import { SharedKeyCredential } from "./credentials/SharedKeyCredential";
import { Credential } from "./credentials/Credential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
/**
 * AppendBlobClient defines a set of operations applicable to append blobs.
 *
 * @export
 * @class AppendBlobClient
 * @extends {BlobClient}
 */
var AppendBlobClient = /** @class */ (function (_super) {
    tslib_1.__extends(AppendBlobClient, _super);
    function AppendBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        var _this = this;
        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.
        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);
        var pipeline;
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if (credentialOrPipelineOrContainerName instanceof Credential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            options = blobNameOrOptions;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string" &&
            blobNameOrOptions &&
            typeof blobNameOrOptions === "string") {
            if (isNode) {
                var containerName = credentialOrPipelineOrContainerName;
                var blobName = blobNameOrOptions;
                var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
                var sharedKeyCredential = new SharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                urlOrConnectionString = extractedCreds.url + "/" + containerName + "/" + blobName;
                pipeline = newPipeline(sharedKeyCredential, options);
            }
            else {
                throw new Error("Connection string is only supported in Node.js environment");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        _this = _super.call(this, urlOrConnectionString, pipeline) || this;
        _this.appendBlobContext = new AppendBlob(_this.storageClientContext);
        return _this;
    }
    /**
     * Creates a new AppendBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {AppendBlobClient} A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.withSnapshot = function (snapshot) {
        return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param {AppendBlobCreateOptions} [options] Options to the Append Block Create operation.
     * @returns {Promise<Models.AppendBlobsCreateResponse>}
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var aborter;
            return tslib_1.__generator(this, function (_a) {
                aborter = options.abortSignal || Aborter.none;
                options.accessConditions = options.accessConditions || {};
                return [2 /*return*/, this.appendBlobContext.create(0, {
                        abortSignal: aborter,
                        blobHTTPHeaders: options.blobHTTPHeaders,
                        leaseAccessConditions: options.accessConditions.leaseAccessConditions,
                        metadata: options.metadata,
                        modifiedAccessConditions: options.accessConditions.modifiedAccessConditions
                    })];
            });
        });
    };
    /**
     * Commits a new block of data to the end of the existing append blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/append-block
     *
     * @param {HttpRequestBody} body Data to be appended.
     * @param {number} contentLength Number of bytes to be appended.
     * @param {AppendBlobAppendBlockOptions} [options] Options to the Append Block operation.
     * @returns {Promise<Models.AppendBlobsAppendBlockResponse>}
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.appendBlock = function (body, contentLength, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var aborter;
            return tslib_1.__generator(this, function (_a) {
                aborter = options.abortSignal || Aborter.none;
                options.accessConditions = options.accessConditions || {};
                return [2 /*return*/, this.appendBlobContext.appendBlock(body, contentLength, {
                        abortSignal: aborter,
                        appendPositionAccessConditions: options.accessConditions.appendPositionAccessConditions,
                        leaseAccessConditions: options.accessConditions.leaseAccessConditions,
                        modifiedAccessConditions: options.accessConditions.modifiedAccessConditions,
                        onUploadProgress: options.progress,
                        transactionalContentMD5: options.transactionalContentMD5
                    })];
            });
        });
    };
    return AppendBlobClient;
}(BlobClient));
export { AppendBlobClient };
//# sourceMappingURL=AppendBlobClient.js.map